<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x6 Word Placement Engine</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .input-section {
            margin-bottom: 30px;
        }
        .words-input {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .generate-btn {
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
        }
        .generate-btn:hover {
            background: #0056b3;
        }
        .results-section {
            margin-top: 30px;
        }
        .grid-result {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f8f9fa;
        }
        .grid-display {
            display: grid;
            grid-template-columns: repeat(6, 40px);
            gap: 2px;
            margin: 10px 0;
        }
        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #333;
            background: white;
            font-weight: bold;
        }
        .cell.word-0 { background-color: #c62828; color: white; } /* Dark Red */
        .cell.word-1 { background-color: #2e7d32; color: white; } /* Dark Green */
        .cell.word-2 { background-color: #1565c0; color: white; } /* Dark Blue */
        .cell.word-3 { background-color: #ef6c00; color: white; } /* Dark Orange */
        .cell.word-4 { background-color: #7b1fa2; color: white; } /* Dark Purple */
        .cell.word-5 { background-color: #00695c; color: white; } /* Dark Teal */
        .cell.filler { background-color: #f5f5f5; color: #666; } /* Gray for fillers */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 10px 0;
            font-size: 14px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }
        .copy-btn {
            background: #dc3545;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        .copy-btn:hover {
            background: #c82333;
        }
        .json-output {
            background: #f1f1f1;
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast.success {
            background: #28a745;
        }
        .toast.error {
            background: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>4×6 Word Placement Engine</h1>
        
        <div class="input-section">
            <label for="words">Enter words (comma-separated):</label>
            <textarea id="words" class="words-input" placeholder="name, age, phone, address"></textarea>
            <br>
            <div style="margin: 10px 0;">
                <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
                    <input type="checkbox" id="randomLetters" checked>
                    <span>Use random letters instead of 'X' for empty cells</span>
                </label>
            </div>
            <button class="generate-btn" onclick="generateGrids()">Generate Multiple Grids</button>
        </div>

        <div class="results-section" id="results"></div>
    </div>

    <script>
        class WordPlacementEngine {
            constructor() {
                this.rows = 4;
                this.cols = 6;
                this.commonWords = new Set([
                    'THE', 'AND', 'FOR', 'ARE', 'BUT', 'NOT', 'YOU', 'ALL', 'CAN', 'HER', 'WAS', 'ONE', 'OUR',
                    'HAD', 'BY', 'UP', 'DO', 'NO', 'IF', 'TO', 'MY', 'IS', 'IN', 'IT', 'ON', 'AS', 'BE', 'AT',
                    'OR', 'AN', 'HE', 'HI', 'SO', 'WE', 'AM', 'GO', 'ME', 'OF', 'HIM', 'HIS', 'HOW', 'MAN',
                    'NEW', 'NOW', 'OLD', 'SEE', 'TWO', 'WHO', 'BOY', 'DID', 'ITS', 'LET', 'PUT', 'SAY', 'SHE',
                    'TOO', 'USE'
                ]);
                this.translations = {
                    // Personal Info
                    'name': { uz: 'ism', ru: 'имя' },
                    'age': { uz: 'yosh', ru: 'возраст' },
                    'phone': { uz: 'telefon', ru: 'телефон' },
                    'address': { uz: 'manzil', ru: 'адрес' },
                    'email': { uz: 'elektron pochta', ru: 'эл. почта' },
                    'birthday': { uz: "tug'ilgan kun", ru: 'день рождения' },
                    
                    // Family
                    'family': { uz: 'oila', ru: 'семья' },
                    'mother': { uz: 'ona', ru: 'мама' },
                    'father': { uz: 'ota', ru: 'папа' },
                    'sister': { uz: 'opa', ru: 'сестра' },
                    'brother': { uz: 'aka', ru: 'брат' },
                    'child': { uz: 'bola', ru: 'ребёнок' },
                    'son': { uz: "o'g'il", ru: 'сын' },
                    'daughter': { uz: 'qiz', ru: 'дочь' },
                    
                    // Work/Education
                    'work': { uz: 'ish', ru: 'работа' },
                    'job': { uz: 'kasb', ru: 'профессия' },
                    'school': { uz: 'maktab', ru: 'школа' },
                    'university': { uz: 'universitet', ru: 'университет' },
                    'student': { uz: 'talaba', ru: 'студент' },
                    'teacher': { uz: "o'qituvchi", ru: 'учитель' },
                    'doctor': { uz: 'shifokor', ru: 'врач' },
                    'engineer': { uz: 'muhandis', ru: 'инженер' },
                    
                    // Time
                    'time': { uz: 'vaqt', ru: 'время' },
                    'day': { uz: 'kun', ru: 'день' },
                    'week': { uz: 'hafta', ru: 'неделя' },
                    'month': { uz: 'oy', ru: 'месяц' },
                    'year': { uz: 'yil', ru: 'год' },
                    'today': { uz: 'bugun', ru: 'сегодня' },
                    'tomorrow': { uz: 'ertaga', ru: 'завтра' },
                    'yesterday': { uz: 'kecha', ru: 'вчера' },
                    
                    // Colors
                    'red': { uz: 'qizil', ru: 'красный' },
                    'blue': { uz: "ko'k", ru: 'синий' },
                    'green': { uz: 'yashil', ru: 'зелёный' },
                    'black': { uz: 'qora', ru: 'чёрный' },
                    'white': { uz: 'oq', ru: 'белый' },
                    'yellow': { uz: 'sariq', ru: 'жёлтый' },
                    
                    // Numbers
                    'one': { uz: 'bir', ru: 'один' },
                    'two': { uz: 'ikki', ru: 'два' },
                    'three': { uz: 'uch', ru: 'три' },
                    'four': { uz: "to'rt", ru: 'четыре' },
                    'five': { uz: 'besh', ru: 'пять' },
                    'six': { uz: 'olti', ru: 'шесть' },
                    'seven': { uz: 'yetti', ru: 'семь' },
                    'eight': { uz: 'sakkiz', ru: 'восемь' },
                    'nine': { uz: "to'qqiz", ru: 'девять' },
                    'ten': { uz: "o'n", ru: 'десять' },
                    
                    // Common Objects
                    'house': { uz: 'uy', ru: 'дом' },
                    'car': { uz: 'mashina', ru: 'машина' },
                    'food': { uz: 'ovqat', ru: 'еда' },
                    'water': { uz: 'suv', ru: 'вода' },
                    'money': { uz: 'pul', ru: 'деньги' },
                    'friend': { uz: "do'st", ru: 'друг' },
                    'book': { uz: 'kitob', ru: 'книга' },
                    'computer': { uz: 'kompyuter', ru: 'компьютер' },
                    
                    // Adjectives
                    'big': { uz: 'katta', ru: 'большой' },
                    'small': { uz: 'kichik', ru: 'маленький' },
                    'good': { uz: 'yaxshi', ru: 'хороший' },
                    'bad': { uz: 'yomon', ru: 'плохой' },
                    'new': { uz: 'yangi', ru: 'новый' },
                    'old': { uz: 'eski', ru: 'старый' },
                    'young': { uz: 'yosh', ru: 'молодой' },
                    'beautiful': { uz: "go'zal", ru: 'красивый' },
                    'happy': { uz: 'xursand', ru: 'счастливый' },
                    'sad': { uz: "g'amgin", ru: 'грустный' }
                };
            }

            getTranslations(words) {
                const translations = {
                    en: words.map(w => w.toLowerCase()),
                    uz: [],
                    ru: []
                };
                
                words.forEach(word => {
                    const lowerWord = word.toLowerCase();
                    const translation = this.translations[lowerWord];
                    
                    if (translation) {
                        translations.uz.push(translation.uz);
                        translations.ru.push(translation.ru);
                    } else {
                        translations.uz.push(lowerWord);
                        translations.ru.push(lowerWord);
                    }
                });
                
                return translations;
            }

            createEmptyGrid() {
                return Array(this.rows).fill().map(() => Array(this.cols).fill(null));
            }

            isValidPosition(grid, row, col) {
                return row >= 0 && row < this.rows && col >= 0 && col < this.cols && grid[row][col] === null;
            }

            canPlaceWord(grid, word, startRow, startCol, path) {
                for (let i = 0; i < word.length; i++) {
                    const [row, col] = path[i];
                    if (!this.isValidPosition(grid, row, col)) {
                        return false;
                    }
                }
                return true;
            }

            generatePaths(word, startRow, startCol) {
                const paths = [];

                // Horizontal path (right)
                if (startCol + word.length <= this.cols) {
                    const horizontalPath = [];
                    for (let i = 0; i < word.length; i++) {
                        horizontalPath.push([startRow, startCol + i]);
                    }
                    paths.push(horizontalPath);
                }

                // Vertical path (down)
                if (startRow + word.length <= this.rows) {
                    const verticalPath = [];
                    for (let i = 0; i < word.length; i++) {
                        verticalPath.push([startRow + i, startCol]);
                    }
                    paths.push(verticalPath);
                }

                // L-shaped paths (2 segments with 90° turn)
                if (word.length >= 3) {
                    // Right then down
                    for (let splitAt = 1; splitAt < word.length; splitAt++) {
                        if (startCol + splitAt < this.cols && startRow + (word.length - splitAt) <= this.rows) {
                            const path = [];
                            // Horizontal segment
                            for (let i = 0; i < splitAt; i++) {
                                path.push([startRow, startCol + i]);
                            }
                            // Vertical segment
                            for (let i = splitAt; i < word.length; i++) {
                                path.push([startRow + (i - splitAt + 1), startCol + splitAt - 1]);
                            }
                            paths.push(path);
                        }
                    }

                    // Down then right
                    for (let splitAt = 1; splitAt < word.length; splitAt++) {
                        if (startRow + splitAt < this.rows && startCol + (word.length - splitAt) <= this.cols) {
                            const path = [];
                            // Vertical segment
                            for (let i = 0; i < splitAt; i++) {
                                path.push([startRow + i, startCol]);
                            }
                            // Horizontal segment
                            for (let i = splitAt; i < word.length; i++) {
                                path.push([startRow + splitAt - 1, startCol + (i - splitAt + 1)]);
                            }
                            paths.push(path);
                        }
                    }
                }

                return paths;
            }

            placeWord(grid, word, path) {
                for (let i = 0; i < word.length; i++) {
                    const [row, col] = path[i];
                    grid[row][col] = word[i].toUpperCase();
                }
            }

            removeWord(grid, path) {
                for (const [row, col] of path) {
                    grid[row][col] = null;
                }
            }

            solveWithBacktracking(grid, words, wordIndex, placements) {
                if (wordIndex === words.length) {
                    return true;
                }

                const word = words[wordIndex];
                const positions = [];

                // Generate all possible starting positions
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        positions.push([row, col]);
                    }
                }

                // Shuffle positions for randomization
                this.shuffleArray(positions);

                for (const [startRow, startCol] of positions) {
                    const paths = this.generatePaths(word, startRow, startCol);
                    this.shuffleArray(paths);

                    for (const path of paths) {
                        if (this.canPlaceWord(grid, word, startRow, startCol, path)) {
                            this.placeWord(grid, word, path);
                            placements.push({ word, path });

                            if (this.solveWithBacktracking(grid, words, wordIndex + 1, placements)) {
                                return true;
                            }

                            this.removeWord(grid, path);
                            placements.pop();
                        }
                    }
                }

                return false;
            }

            solveWithBacktrackingWithOwnership(grid, ownerGrid, words, wordIndex, placements) {
                if (wordIndex === words.length) {
                    return true;
                }

                const word = words[wordIndex];
                const positions = [];

                // Generate all possible starting positions
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        positions.push([row, col]);
                    }
                }

                // Shuffle positions for randomization
                this.shuffleArray(positions);

                for (const [startRow, startCol] of positions) {
                    const paths = this.generatePaths(word, startRow, startCol);
                    
                    this.shuffleArray(paths);

                    for (const path of paths) {
                        if (this.canPlaceWord(grid, word, startRow, startCol, path)) {
                            this.placeWordWithOwnership(grid, ownerGrid, word, path, wordIndex);
                            placements.push({ word, path, wordIndex });

                            if (this.solveWithBacktrackingWithOwnership(grid, ownerGrid, words, wordIndex + 1, placements)) {
                                return true;
                            }

                            this.removeWordWithOwnership(grid, ownerGrid, path);
                            placements.pop();
                        }
                    }
                }

                return false;
            }

            placeWordWithOwnership(grid, ownerGrid, word, path, wordIndex) {
                for (let i = 0; i < word.length; i++) {
                    const [row, col] = path[i];
                    grid[row][col] = word[i].toUpperCase();
                    ownerGrid[row][col] = wordIndex;
                }
            }

            removeWordWithOwnership(grid, ownerGrid, path) {
                for (const [row, col] of path) {
                    grid[row][col] = null;
                    ownerGrid[row][col] = null;
                }
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            getRandomLetter() {
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                return letters[Math.floor(Math.random() * letters.length)];
            }

            isCommonWord(str) {
                return this.commonWords.has(str.toUpperCase());
            }

            addFillerLetters(grid, ownerGrid, useRandomLetters = true) {
                const finalGrid = grid.map(row => [...row]);
                const randomLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (finalGrid[row][col] === null) {
                            if (useRandomLetters) {
                                finalGrid[row][col] = randomLetters[Math.floor(Math.random() * randomLetters.length)];
                            } else {
                                finalGrid[row][col] = 'X';
                            }
                            // Mark filler cells as owned by -1
                            if (ownerGrid) {
                                ownerGrid[row][col] = -1;
                            }
                        }
                    }
                }
                return finalGrid;
            }

            generateGrid(words, useRandomLetters = true) {
                const maxAttempts = 50;
                
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const grid = this.createEmptyGrid();
                    const wordOwnerGrid = this.createEmptyGrid();
                    const placements = [];
                    const shuffledWords = [...words];
                    this.shuffleArray(shuffledWords);

                    if (this.solveWithBacktrackingWithOwnership(grid, wordOwnerGrid, shuffledWords, 0, placements)) {
                        const finalGrid = this.addFillerLetters(grid, wordOwnerGrid, useRandomLetters);
                        return {
                            success: true,
                            grid: finalGrid,
                            wordOwnerGrid: wordOwnerGrid,
                            placements: placements
                        };
                    }
                }

                return { success: false, error: "Could not place all words after maximum attempts" };
            }

            generateMultipleGrids(words, count = 5, useRandomLetters = true) {
                const results = [];
                const normalizedWords = words.map(w => w.trim().toUpperCase()).filter(w => w.length > 0);

                if (normalizedWords.length === 0) {
                    return [{ success: false, error: "No valid words provided" }];
                }

                // Check if total letters can fit
                const totalLetters = normalizedWords.reduce((sum, word) => sum + word.length, 0);
                if (totalLetters > 24) {
                    return [{ success: false, error: "Total word length exceeds grid capacity (24 cells)" }];
                }

                for (let i = 0; i < count; i++) {
                    try {
                        const result = this.generateGrid(normalizedWords, useRandomLetters);
                        if (result && result.success) {
                            const targetWords = normalizedWords.map(w => w.toLowerCase());
                            const translations = this.getTranslations(targetWords);
                            
                            results.push({
                                title: `Word Grid (4x6)`,
                                order_id: i + 1,
                                grid: result.grid,
                                wordOwnerGrid: result.wordOwnerGrid,
                                rows: this.rows,
                                columns: this.cols,
                                targetWords: targetWords,
                                translations: translations,
                                is_active: true
                            });
                        }
                    } catch (error) {
                        // Silent fail
                    }
                }

                if (results.length === 0) {
                    return [{ success: false, error: "Could not generate any valid grids. Try fewer or shorter words." }];
                }

                return results;
            }
        }

        function generateGrids() {
            const wordsInput = document.getElementById('words').value;
            const words = wordsInput.split(',').map(w => w.trim()).filter(w => w.length > 0);
            const useRandomLetters = document.getElementById('randomLetters').checked;
            
            if (words.length === 0) {
                document.getElementById('results').innerHTML = '<div class="error">Please enter some words!</div>';
                return;
            }

            const engine = new WordPlacementEngine();
            const results = engine.generateMultipleGrids(words, 5, useRandomLetters);
            displayResults(results);
        }

        function displayResults(results) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';

            if (!results || results.length === 0) {
                resultsDiv.innerHTML = '<div class="error">No results generated</div>';
                return;
            }

            results.forEach((result, index) => {
                
                const resultDiv = document.createElement('div');
                resultDiv.className = 'grid-result';

                if (!result || result.success === false) {
                    resultDiv.innerHTML = `<div class="error">Error: ${result ? result.error : 'Unknown error'}</div>`;
                    resultsDiv.appendChild(resultDiv);
                    return;
                }

                // Check if result has required properties
                if (!result.grid || !result.title || !result.targetWords) {
                    resultDiv.innerHTML = `<div class="error">Invalid result structure</div>`;
                    resultsDiv.appendChild(resultDiv);
                    return;
                }

                const gridDisplay = document.createElement('div');
                gridDisplay.className = 'grid-display';

                result.grid.forEach((row, rowIndex) => {
                    row.forEach((cell, colIndex) => {
                        const cellDiv = document.createElement('div');
                        cellDiv.className = 'cell';
                        cellDiv.textContent = cell || '';
                        
                        // Color coding based on word ownership
                        if (result.wordOwnerGrid && result.wordOwnerGrid[rowIndex] && result.wordOwnerGrid[rowIndex][colIndex] !== null && result.wordOwnerGrid[rowIndex][colIndex] !== undefined) {
                            const wordIndex = result.wordOwnerGrid[rowIndex][colIndex];
                            if (wordIndex === -1) {
                                // Filler cell
                                cellDiv.classList.add('filler');
                            } else {
                                // Word cell
                                cellDiv.classList.add(`word-${wordIndex}`);
                            }
                        } else if (cell === 'X') {
                            cellDiv.classList.add('filler');
                        } else {
                        }
                        
                        gridDisplay.appendChild(cellDiv);
                    });
                });

                // Create legend
                const legend = document.createElement('div');
                legend.className = 'legend';
                
                result.targetWords.forEach((word, index) => {
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = `legend-color word-${index}`;
                    colorBox.textContent = word[0].toUpperCase();
                    
                    const label = document.createElement('span');
                    label.textContent = word.toUpperCase();
                    
                    legendItem.appendChild(colorBox);
                    legendItem.appendChild(label);
                    legend.appendChild(legendItem);
                });

                const jsonString = JSON.stringify(result, null, 2);
                
                resultDiv.innerHTML = `
                    <h3>${result.title} - Order ID: ${result.order_id}</h3>
                    <div><strong>Target Words:</strong> ${result.targetWords.join(', ')}</div>
                    <div style="margin: 10px 0;">${gridDisplay.outerHTML}</div>
                    <button class="copy-btn" onclick="copyJSON('${result.order_id}')">Copy JSON</button>
                    <div class="json-output" id="json-${result.order_id}">${escapeHtml(jsonString)}</div>
                `;

                resultsDiv.appendChild(resultDiv);
            });
        }

        function copyJSON(orderId) {
            const jsonElement = document.getElementById(`json-${orderId}`);
            if (!jsonElement) {
                showToast('JSON not found', 'error');
                return;
            }
            
            const jsonText = jsonElement.textContent;
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(jsonText)
                    .then(() => {
                        showToast('JSON copied!', 'success');
                    })
                    .catch(() => {
                        fallbackCopy(jsonText);
                    });
            } else {
                fallbackCopy(jsonText);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                const success = document.execCommand('copy');
                showToast(success ? 'JSON copied!' : 'Copy failed', success ? 'success' : 'error');
            } catch (e) {
                showToast('Copy failed', 'error');
            }
            
            document.body.removeChild(textarea);
        }

        function escapeQuotes(str) {
            return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);
            
            // Remove toast after 3 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (document.body.contains(toast)) {
                        document.body.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Auto-generate example on page load
        window.onload = function() {
            document.getElementById('words').value = 'name, age, phone, address';
        };
    </script>
</body>
</html>